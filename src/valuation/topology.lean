import for_mathlib.nonarchimedean.is_subgroups_basis
import for_mathlib.uniform_space.group_basis
import valuation.basic

/-!
# The topology on a valued ring

In this file, we define the topology induced by a valuation on a ring.
-/

local attribute [instance] classical.prop_decidable
noncomputable theory

local attribute [instance, priority 10] classical.decidable_linear_order

open set valuation linear_ordered_structure

local notation `ùìù` x: 70 := nhds x

section
variables {Œì‚ÇÄ : Type*} [linear_ordered_comm_group_with_zero Œì‚ÇÄ]
variables {R : Type*} [ring R]

/-- The subgroup of elements whose valuation is less than a certain unit.-/
def valuation.subgroup (v : valuation R Œì‚ÇÄ) (Œ≥ : units Œì‚ÇÄ) : set R := {x | v x < Œ≥}

lemma valuation.lt_is_add_subgroup (v : valuation R Œì‚ÇÄ) (Œ≥ : units Œì‚ÇÄ) :
  is_add_subgroup {x | v x < Œ≥} :=
{ zero_mem := by { have h := group_with_zero.unit_ne_zero Œ≥, contrapose! h, simpa using h },
  add_mem := Œª x y x_in y_in, lt_of_le_of_lt (v.map_add x y) (max_lt x_in y_in),
  neg_mem := Œª x x_in, by rwa [mem_set_of_eq, map_neg] }

-- is this an OK place to put this?
lemma valuation.le_is_add_subgroup (v : valuation R Œì‚ÇÄ) (Œ≥ : units Œì‚ÇÄ) : is_add_subgroup {x | v x ‚â§ Œ≥} :=
{ zero_mem := by simp,
  add_mem := Œª x y x_in y_in, le_trans (v.map_add x y) (max_le x_in y_in),
  neg_mem := Œª x x_in, by rwa [mem_set_of_eq, map_neg] }

end

local attribute [instance] valuation.lt_is_add_subgroup

universe u

/-- A valued ring is a ring that comes equipped with a distinguished valuation.-/
class valued (R : Type u) [ring R] :=
(Œì‚ÇÄ : Type u)
[grp : linear_ordered_comm_group_with_zero Œì‚ÇÄ]
(v : valuation R Œì‚ÇÄ)

attribute [instance] valued.grp

open valued

namespace valued
variables {R : Type*} [ring R] [valued R]

/-- The function underlying the valuation of a valued ring.-/
def value : R ‚Üí (valued.Œì‚ÇÄ R) := (valued.v R)

local notation `v` := valued.value

-- The following four lemmas are restatements that seem to be unfortunately needed

lemma map_zero : v (0 : R) = 0 :=
valuation.map_zero _

lemma map_one : v (1 : R) = 1 :=
valuation.map_one _

lemma map_mul (x y : R) : v (x*y) = v x * v y :=
valuation.map_mul _ _ _

lemma map_add (x y : R) : v (x+y) ‚â§ max (v x) (v y) :=
valuation.map_add _ _ _

/-- The basis of open subgroups for the topology on a valued ring.-/
def subgroups_basis : subgroups_basis R :=
{ sets := range (valued.v R).subgroup,
  ne_empty := ne_empty_of_mem (mem_range_self 1),
  directed := begin
    rintros _ _ ‚ü®Œ≥‚ÇÄ, rfl‚ü© ‚ü®Œ≥‚ÇÅ, rfl‚ü©,
    rw exists_mem_range,
    use min Œ≥‚ÇÄ Œ≥‚ÇÅ,
    simp only [set_of_subset_set_of, subset_inter_iff, valuation.subgroup],
    split ; intros x x_lt ;  rw coe_min at x_lt,
    { exact lt_of_lt_of_le x_lt (min_le_left _ _) },
    { exact lt_of_lt_of_le x_lt (min_le_right _ _) }
  end,
  sub_groups := by { rintros _ ‚ü®Œ≥, rfl‚ü©, exact (valued.v R).lt_is_add_subgroup Œ≥ },
  h_mul := begin
    rintros _ ‚ü®Œ≥, rfl‚ü©,
    rw set.exists_mem_range',
    cases linear_ordered_structure.exists_square_le Œ≥ with Œ≥‚ÇÄ h,
    replace h : (Œ≥‚ÇÄ*Œ≥‚ÇÄ : valued.Œì‚ÇÄ R) ‚â§ Œ≥, exact_mod_cast h,
    use Œ≥‚ÇÄ,
    rintro x ‚ü®r, r_in, s, s_in, rfl‚ü©,
    refine lt_of_lt_of_le _ h,
    rw valuation.map_mul,
    exact mul_lt_mul' r_in s_in
  end,
  h_left_mul := begin
      rintros x _ ‚ü®Œ≥, rfl‚ü©,
      rw exists_mem_range',
     dsimp [valuation.subgroup],
      by_cases Hx : ‚àÉ Œ≥x : units (Œì‚ÇÄ R), v x = (Œ≥x : Œì‚ÇÄ R),
      { cases Hx with Œ≥x Hx,
        simp only [image_subset_iff, set_of_subset_set_of, preimage_set_of_eq, valuation.map_mul],
        use Œ≥x‚Åª¬π*Œ≥,
        intros y vy_lt,
        change  v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥) at vy_lt,
        change v x * v y < ‚ÜëŒ≥,
        rw Hx,
        rw units.coe_mul at vy_lt,
        apply actual_ordered_comm_monoid.lt_of_mul_lt_mul_left (Œ≥x‚Åª¬π : Œì‚ÇÄ R),
        rwa [‚Üê mul_assoc, inv_mul_cancel' _ (group_with_zero.unit_ne_zero _), one_mul,
          ‚Üê group_with_zero.coe_inv_unit] },
      { rw [‚Üê ne_zero_iff_exists, not_not] at Hx,
        use 1,
        intros y y_in,
        erw [mem_set_of_eq, valuation.map_mul],
        change v x * v y < _,
        erw [Hx, zero_mul],
        exact zero_lt_unit _ }
  end,
  h_right_mul := begin
    rintros x _ ‚ü®Œ≥, rfl‚ü©,
    rw exists_mem_range',
    dsimp [valuation.subgroup],
    by_cases Hx : ‚àÉ Œ≥x : units (Œì‚ÇÄ R), v x = Œ≥x,
    { cases Hx with Œ≥x Hx,
      simp only [image_subset_iff, set_of_subset_set_of, preimage_set_of_eq, valuation.map_mul],
      use Œ≥ * Œ≥x‚Åª¬π,
      intros y vy_lt,
      change v y * v x < _,
      rw Hx,
      apply actual_ordered_comm_monoid.lt_of_mul_lt_mul_right' (Œ≥x‚Åª¬π : Œì‚ÇÄ R),
      rwa [mul_assoc, mul_inv_cancel' _ (group_with_zero.unit_ne_zero _), mul_one,
        ‚Üê group_with_zero.coe_inv_unit], },
    { rw [‚Üê ne_zero_iff_exists, not_not] at Hx,
      use 1,
      intros y y_in,
      rw [mem_set_of_eq, valuation.map_mul],
      change v y * v x < _,
      erw [Hx, mul_zero],
      exact zero_lt_unit _ }
  end }

local attribute [instance] valued.subgroups_basis subgroups_basis.topology ring_filter_basis.topological_ring

lemma mem_basis_zero {s : set R} :
  s ‚àà filter_basis.sets R ‚Üî ‚àÉ Œ≥ : units (valued.Œì‚ÇÄ R), {x | valued.v R x < (Œ≥ : valued.Œì‚ÇÄ R)} = s :=
iff.rfl


lemma mem_nhds {s : set R} {x : R} :
  (s ‚àà ùìù x) ‚Üî ‚àÉ Œ≥ : units (valued.Œì‚ÇÄ R), {y | v (y - x) < Œ≥ } ‚äÜ s :=
begin
  erw [subgroups_basis.mem_nhds, exists_mem_range],
  exact iff.rfl,
end

lemma mem_nhds_zero {s : set R} :
  (s ‚àà ùìù (0 : R)) ‚Üî ‚àÉ Œ≥ : units (Œì‚ÇÄ R), {x | v x < (Œ≥ : Œì‚ÇÄ R) } ‚äÜ s :=
by simp [valued.mem_nhds, sub_zero]

lemma loc_const {x : R} (h : v x ‚â† 0) : {y : R | v y = v x} ‚àà ùìù x :=
begin
  rw valued.mem_nhds,
  rcases ne_zero_iff_exists.mp h with ‚ü®Œ≥, hx‚ü©,
  use Œ≥,
  rw ‚Üê hx,
  intros y y_in,
  exact valuation.map_eq_of_sub_lt _ y_in
end

/-- The uniform structure on a valued ring.-/
def uniform_space : uniform_space R :=
topological_add_group.to_uniform_space R

local attribute [instance] valued.uniform_space

/-- A valued ring is a uniform additive group.-/
lemma uniform_add_group : uniform_add_group R :=
topological_add_group_is_uniform

local attribute [instance] valued.uniform_add_group

lemma cauchy_iff {F : filter R} :
  cauchy F ‚Üî F ‚â† ‚ä• ‚àß ‚àÄ Œ≥ : units (valued.Œì‚ÇÄ R), ‚àÉ M ‚àà F,
    ‚àÄ x y, x ‚àà M ‚Üí y ‚àà M ‚Üí y - x ‚àà {x : R | valued.v R x < ‚ÜëŒ≥} :=
begin
    rw add_group_filter_basis.cauchy_iff R rfl,
    apply and_congr iff.rfl,
    split,
    { intros h Œ≥,
      apply h,
      erw valued.mem_basis_zero,
      use Œ≥ },
    { intros h U U_in,
      rcases valued.mem_basis_zero.mp U_in with ‚ü®Œ≥, rfl‚ü©, clear U_in,
      apply h }
end
end valued
